"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sugar-high";
exports.ids = ["vendor-chunks/sugar-high"];
exports.modules = {

/***/ "(rsc)/./node_modules/sugar-high/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/sugar-high/lib/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SugarHigh: () => (/* binding */ SugarHigh),\n/* harmony export */   highlight: () => (/* binding */ highlight),\n/* harmony export */   tokenize: () => (/* binding */ tokenize)\n/* harmony export */ });\n// @ts-check\nconst jsxBrackets = new Set([\n    \"<\",\n    \">\",\n    \"{\",\n    \"}\",\n    \"[\",\n    \"]\"\n]);\nconst keywords = new Set([\n    \"for\",\n    \"do\",\n    \"while\",\n    \"if\",\n    \"else\",\n    \"return\",\n    \"function\",\n    \"var\",\n    \"let\",\n    \"const\",\n    \"true\",\n    \"false\",\n    \"undefined\",\n    \"this\",\n    \"new\",\n    \"delete\",\n    \"typeof\",\n    \"in\",\n    \"instanceof\",\n    \"void\",\n    \"break\",\n    \"continue\",\n    \"switch\",\n    \"case\",\n    \"default\",\n    \"throw\",\n    \"try\",\n    \"catch\",\n    \"finally\",\n    \"debugger\",\n    \"with\",\n    \"yield\",\n    \"async\",\n    \"await\",\n    \"class\",\n    \"extends\",\n    \"super\",\n    \"import\",\n    \"export\",\n    \"from\",\n    \"static\"\n]);\nconst signs = new Set([\n    \"+\",\n    \"-\",\n    \"*\",\n    \"/\",\n    \"%\",\n    \"=\",\n    \"!\",\n    \"&\",\n    \"|\",\n    \"^\",\n    \"~\",\n    \"!\",\n    \"?\",\n    \":\",\n    \".\",\n    \",\",\n    \";\",\n    `'`,\n    '\"',\n    \".\",\n    \"(\",\n    \")\",\n    \"[\",\n    \"]\",\n    \"#\",\n    \"@\",\n    \"\\\\\",\n    ...jsxBrackets\n]);\n/**\n *\n * 0  - identifier\n * 1  - keyword\n * 2  - string\n * 3  - Class, number and null\n * 4  - property\n * 5  - entity\n * 6  - jsx literals\n * 7  - sign\n * 8  - comment\n * 9  - break\n * 10 - space\n *\n */ const types = /** @type {const} */ [\n    \"identifier\",\n    \"keyword\",\n    \"string\",\n    \"class\",\n    \"property\",\n    \"entity\",\n    \"jsxliterals\",\n    \"sign\",\n    \"comment\",\n    \"break\",\n    \"space\"\n];\nconst [T_IDENTIFIER, T_KEYWORD, T_STRING, T_CLS_NUMBER, T_PROPERTY, T_ENTITY, T_JSX_LITERALS, T_SIGN, T_COMMENT, T_BREAK, T_SPACE] = /** @types {const} */ types.map((_, i)=>i);\nfunction isSpaces(str) {\n    return /^[^\\S\\r\\n]+$/g.test(str);\n}\nfunction isSign(ch) {\n    return signs.has(ch);\n}\nfunction encode(str) {\n    return str.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#039;\");\n}\nfunction isWord(chr) {\n    return /^[\\w_]+$/.test(chr) || hasUnicode(chr);\n}\nfunction isCls(str) {\n    const chr0 = str[0];\n    return isWord(chr0) && chr0 === chr0.toUpperCase() || str === \"null\";\n}\nfunction hasUnicode(s) {\n    return /[^\\u0000-\\u007f]/.test(s);\n}\nfunction isAlpha(chr) {\n    return /^[a-zA-Z]$/.test(chr);\n}\nfunction isIdentifierChar(chr) {\n    return isAlpha(chr) || hasUnicode(chr);\n}\nfunction isIdentifier(str) {\n    return isIdentifierChar(str[0]) && (str.length === 1 || isWord(str.slice(1)));\n}\nfunction isStrTemplateChr(chr) {\n    return chr === \"`\";\n}\nfunction isSingleQuotes(chr) {\n    return chr === '\"' || chr === \"'\";\n}\nfunction isStringQuotation(chr) {\n    return isSingleQuotes(chr) || isStrTemplateChr(chr);\n}\nfunction isCommentStart(str) {\n    str = str.slice(0, 2);\n    return str === \"//\" || str === \"/*\";\n}\nfunction isRegexStart(str) {\n    return str[0] === \"/\" && !isCommentStart(str[0] + str[1]);\n}\n/**\n * @param {string} code\n * @return {Array<[number, string]>}\n */ function tokenize(code) {\n    let current = \"\";\n    let type = -1;\n    /** @type {[number, string]} */ let last = [\n        -1,\n        \"\"\n    ];\n    /** @type {[number, string]} */ let beforeLast = [\n        -2,\n        \"\"\n    ];\n    /** @type {Array<[number, string]>} */ const tokens = [];\n    /** @type boolean if entered jsx tag, inside <open tag> or </close tag> */ let __jsxEnter = false;\n    /**\n   * @type {0 | 1 | 2}\n   * @example\n   * 0 for not in jsx;\n   * 1 for open jsx tag;\n   * 2 for closing jsx tag;\n   **/ let __jsxTag = 0;\n    let __jsxExpr = false;\n    // only match paired (open + close) tags, not self-closing tags\n    let __jsxStack = 0;\n    const __jsxChild = ()=>__jsxEnter && !__jsxExpr && !__jsxTag;\n    // < __content__ >\n    const inJsxTag = ()=>__jsxTag && !__jsxChild();\n    // {'__content__'}\n    const inJsxLiterals = ()=>!__jsxTag && __jsxChild() && !__jsxExpr && __jsxStack > 0;\n    /** @type {string | null} */ let __strQuote = null;\n    let __strTemplateExprStack = 0;\n    let __strTemplateQuoteStack = 0;\n    const inStringQuotes = ()=>__strQuote !== null;\n    const inStrTemplateLiterals = ()=>__strTemplateQuoteStack > __strTemplateExprStack;\n    const inStrTemplateExpr = ()=>__strTemplateQuoteStack > 0 && __strTemplateQuoteStack === __strTemplateExprStack;\n    const inStringContent = ()=>inStringQuotes() || inStrTemplateLiterals();\n    /**\n   *\n   * @param {string} token\n   * @returns {number}\n   */ function classify(token) {\n        const isLineBreak = token === \"\\n\";\n        // First checking if they're attributes values\n        if (inJsxTag()) {\n            if (inStringQuotes()) {\n                return T_STRING;\n            }\n            const [, lastToken] = last;\n            if (isIdentifier(token)) {\n                // classify jsx open tag\n                if (lastToken === \"<\" || lastToken === \"</\") return T_ENTITY;\n            }\n        }\n        // Then determine if they're jsx literals\n        const isJsxLiterals = inJsxLiterals();\n        if (isJsxLiterals) return T_JSX_LITERALS;\n        // Determine strings first before other types\n        if (inStringQuotes()) {\n            return T_STRING;\n        } else if (keywords.has(token)) {\n            return last[1] === \".\" ? T_IDENTIFIER : T_KEYWORD;\n        } else if (isLineBreak) {\n            return T_BREAK;\n        } else if (isSpaces(token)) {\n            return T_SPACE;\n        } else if (token.split(\"\").every(isSign)) {\n            return T_SIGN;\n        } else if (isCls(token)) {\n            return inJsxTag() ? T_IDENTIFIER : T_CLS_NUMBER;\n        } else {\n            if (isIdentifier(token)) {\n                const isLastPropDot = last[1] === \".\" && isIdentifier(beforeLast[1]);\n                if (!inStringContent() && !isLastPropDot) return T_IDENTIFIER;\n                if (isLastPropDot) return T_PROPERTY;\n            }\n            return T_STRING;\n        }\n    }\n    const append = (_type, _token)=>{\n        if (_token) {\n            current = _token;\n        }\n        if (current) {\n            type = _type || classify(current);\n            /** @type [number, string]  */ const pair = [\n                type,\n                current\n            ];\n            if (type !== T_SPACE && type !== T_BREAK) {\n                beforeLast = last;\n                last = pair;\n            }\n            tokens.push(pair);\n        }\n        current = \"\";\n    };\n    for(let i = 0; i < code.length; i++){\n        const curr = code[i];\n        const prev = code[i - 1];\n        const next = code[i + 1];\n        const p_c = prev + curr // previous and current\n        ;\n        const c_n = curr + next // current and next\n        ;\n        // Determine string quotation outside of jsx literals.\n        // Inside jsx literals, string quotation is still part of it.\n        if (isSingleQuotes(curr) && !inJsxLiterals()) {\n            append();\n            if (prev !== `\\\\`) {\n                if (__strQuote && curr === __strQuote) {\n                    __strQuote = null;\n                } else if (!__strQuote) {\n                    __strQuote = curr;\n                }\n            }\n            append(T_STRING, curr);\n            continue;\n        }\n        if (!inStrTemplateLiterals()) {\n            if (prev !== \"\\\\n\" && isStrTemplateChr(curr)) {\n                append();\n                append(T_STRING, curr);\n                __strTemplateQuoteStack++;\n                continue;\n            }\n        }\n        if (inStrTemplateLiterals()) {\n            if (prev !== \"\\\\n\" && isStrTemplateChr(curr)) {\n                if (__strTemplateQuoteStack > 0) {\n                    append();\n                    __strTemplateQuoteStack--;\n                    append(T_STRING, curr);\n                    continue;\n                }\n            }\n            if (c_n === \"${\") {\n                __strTemplateExprStack++;\n                append(T_STRING);\n                append(T_SIGN, c_n);\n                i++;\n                continue;\n            }\n        }\n        if (inStrTemplateExpr() && curr === \"}\") {\n            append();\n            __strTemplateExprStack--;\n            append(T_SIGN, curr);\n            continue;\n        }\n        if (__jsxChild()) {\n            if (curr === \"{\") {\n                append();\n                append(T_SIGN, curr);\n                __jsxExpr = true;\n                continue;\n            }\n        }\n        if (__jsxEnter) {\n            // <: open tag sign\n            // new '<' not inside jsx\n            if (!__jsxTag && curr === \"<\") {\n                append();\n                if (next === \"/\") {\n                    // close tag\n                    __jsxTag = 2;\n                    current = c_n;\n                    i++;\n                } else {\n                    // open tag\n                    __jsxTag = 1;\n                    current = curr;\n                }\n                append(T_SIGN);\n                continue;\n            }\n            if (__jsxTag) {\n                // >: open tag close sign or closing tag closing sign\n                // and it's not `=>` or `/>`\n                // `curr` could be `>` or `/`\n                if (curr === \">\" && !\"/=\".includes(prev)) {\n                    append();\n                    if (__jsxTag === 1) {\n                        __jsxTag = 0;\n                        __jsxStack++;\n                    } else {\n                        __jsxTag = 0;\n                        __jsxEnter = false;\n                    }\n                    append(T_SIGN, curr);\n                    continue;\n                }\n                // >: tag self close sign or close tag sign\n                if (c_n === \"/>\" || c_n === \"</\") {\n                    // if current token is not part of close tag sign, push it first\n                    if (current !== \"<\" && current !== \"/\") {\n                        append();\n                    }\n                    if (c_n === \"/>\") {\n                        __jsxTag = 0;\n                    } else {\n                        // is '</'\n                        __jsxStack--;\n                    }\n                    if (!__jsxStack) __jsxEnter = false;\n                    current = c_n;\n                    i++;\n                    append(T_SIGN);\n                    continue;\n                }\n                // <: open tag sign\n                if (curr === \"<\") {\n                    append();\n                    current = curr;\n                    append(T_SIGN);\n                    continue;\n                }\n                // jsx property\n                // `-` in data-prop\n                if (next === \"-\" && !inStringContent() && !inJsxLiterals()) {\n                    if (current) {\n                        append(T_PROPERTY, current + curr + next);\n                        i += 1;\n                        continue;\n                    }\n                }\n                // `=` in property=<value>\n                if (next === \"=\" && !inStringContent()) {\n                    const prop = current ? current + curr : curr;\n                    if (isIdentifier(prop)) {\n                        current = prop;\n                        append(T_PROPERTY);\n                    }\n                    continue;\n                }\n            }\n        }\n        // if it's not in a jsx tag declaration or a string, close child if next is jsx close tag\n        if (!__jsxTag && (curr === \"<\" && isIdentifierChar(next) || c_n === \"</\")) {\n            __jsxTag = next === \"/\" ? 2 : 1;\n            // current and next char can form a jsx open or close tag\n            if (curr === \"<\" && (next === \"/\" || isAlpha(next))) {\n                __jsxEnter = true;\n            }\n        }\n        const isQuotationChar = isStringQuotation(curr);\n        const isStringTemplateLiterals = inStrTemplateLiterals();\n        const isRegexChar = !__jsxEnter && isRegexStart(c_n);\n        const isJsxLiterals = inJsxLiterals();\n        // string quotation\n        if (isQuotationChar || isStringTemplateLiterals || isSingleQuotes(__strQuote)) {\n            current += curr;\n        } else if (isRegexChar) {\n            append();\n            const [lastType, lastToken] = last;\n            // Special cases that are not considered as regex:\n            // * (expr1) / expr2: `)` before `/` operator is still in expression\n            // * <non comment start>/ expr: non comment start before `/` is not regex\n            if (isRegexChar && lastType !== -1 && !(lastType === T_SIGN && \")\" !== lastToken || lastType === T_COMMENT)) {\n                current = curr;\n                append();\n                continue;\n            }\n            const start = i++;\n            // end of line of end of file\n            const isEof = ()=>i >= code.length;\n            const isEol = ()=>isEof() || code[i] === \"\\n\";\n            let foundClose = false;\n            // regex\n            for(; !isEol(); i++){\n                if (code[i] === \"/\" && code[i - 1] !== \"\\\\\") {\n                    foundClose = true;\n                    // append regex flags\n                    while(start !== i && /^[a-z]$/.test(code[i + 1]) && !isEol()){\n                        i++;\n                    }\n                    break;\n                }\n            }\n            if (start !== i && foundClose) {\n                // If current line is fully closed with string quotes or regex slashes,\n                // add them to tokens\n                current = code.slice(start, i + 1);\n                append(T_STRING);\n            } else {\n                // If it doesn't match any of the above, just leave it as operator and move on\n                current = curr;\n                append();\n                i = start;\n            }\n        } else if (isCommentStart(c_n)) {\n            append();\n            const start = i;\n            if (next === \"/\") {\n                for(; i < code.length && code[i] !== \"\\n\"; i++);\n            } else {\n                for(; i < code.length && code[i - 1] + code[i] !== \"*/\"; i++);\n            }\n            current = code.slice(start, i + 1);\n            append(T_COMMENT);\n        } else if (curr === \" \" || curr === \"\\n\") {\n            if (curr === \" \" && (isSpaces(current) || !current || isJsxLiterals)) {\n                current += curr;\n                if (next === \"<\") {\n                    append();\n                }\n            } else {\n                append();\n                current = curr;\n                append();\n            }\n        } else {\n            if (__jsxExpr && curr === \"}\") {\n                append();\n                current = curr;\n                append();\n                __jsxExpr = false;\n            } else if (// it's jsx literals and is not a jsx bracket\n            isJsxLiterals && !jsxBrackets.has(curr) || // same type char as previous one in current token\n            (isWord(curr) === isWord(current[current.length - 1]) || __jsxChild()) && !signs.has(curr)) {\n                current += curr;\n            } else {\n                if (p_c === \"</\") {\n                    current = p_c;\n                }\n                append();\n                if (p_c !== \"</\") {\n                    current = curr;\n                }\n                if (c_n === \"</\" || c_n === \"/>\") {\n                    current = c_n;\n                    append();\n                    i++;\n                } else if (jsxBrackets.has(curr)) append();\n            }\n        }\n    }\n    append();\n    return tokens;\n}\n/**\n * @param {Array<[number, string]>} tokens\n * @return {Array<string>}\n */ function generate(tokens) {\n    const linesHtml = [];\n    const createLine = (content)=>`<span class=\"sh__line\">${content}</span>`;\n    function flushLine(tokens) {\n        linesHtml.push(createLine(tokens.map(([type, value])=>`<span class=\"sh__token--${types[type]}\" style=\"color: var(--sh-${types[type]})\">${encode(value)}</span>`).join(\"\")));\n    }\n    const lineTokens = [];\n    for(let i = 0; i < tokens.length; i++){\n        const token = tokens[i];\n        const [type, value] = token;\n        if (type !== T_BREAK) {\n            // Divide multi-line token into multi-line code\n            if (value.includes(\"\\n\")) {\n                const lines = value.split(\"\\n\");\n                for(let j = 0; j < lines.length; j++){\n                    lineTokens.push([\n                        type,\n                        lines[j]\n                    ]);\n                    if (j < lines.length - 1) {\n                        flushLine(lineTokens);\n                        lineTokens.length = 0;\n                    }\n                }\n            } else {\n                lineTokens.push(token);\n            }\n        } else {\n            lineTokens.push([\n                type,\n                \"\"\n            ]);\n            flushLine(lineTokens);\n            lineTokens.length = 0;\n        }\n    }\n    if (lineTokens.length) flushLine(lineTokens);\n    return linesHtml;\n}\n/**\n *\n * @param {string} code\n * @returns {string}\n */ function highlight(code) {\n    const tokens = tokenize(code);\n    const output = generate(tokens).join(\"\\n\");\n    return output;\n}\n// namespace\nconst SugarHigh = /** @type {const} */ {\n    TokenTypes: types\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3VnYXItaGlnaC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsWUFBWTtBQUVaLE1BQU1BLGNBQWMsSUFBSUMsSUFBSTtJQUFDO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztDQUFJO0FBQzFELE1BQU1DLFdBQVcsSUFBSUQsSUFBSTtJQUN2QjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFRCxNQUFNRSxRQUFRLElBQUlGLElBQUk7SUFDcEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLENBQUMsQ0FBQyxDQUFDO0lBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO09BQ0dEO0NBQ0o7QUFHRDs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNELE1BQU1JLFFBQVEsa0JBQWtCLEdBQUk7SUFDbEM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBQ0QsTUFBTSxDQUNKQyxjQUNBQyxXQUNBQyxVQUNBQyxjQUNBQyxZQUNBQyxVQUNBQyxnQkFDQUMsUUFDQUMsV0FDQUMsU0FDQUMsUUFDRCxHQUFHLG1CQUFtQixHQUFHWCxNQUFNWSxHQUFHLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUE7QUFFOUMsU0FBU0MsU0FBU0MsR0FBRztJQUNuQixPQUFPLGdCQUFnQkMsSUFBSSxDQUFDRDtBQUM5QjtBQUVBLFNBQVNF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V3ZCLElBQUksQ0FBQ1g7WUFDbEI7UUFDRixPQUFPO1lBQ0xrQyxXQUFXdkIsSUFBSSxDQUFDO2dCQUFDOUI7Z0JBQU07YUFBRztZQUMxQmtELFVBQVVHO1lBQ1ZBLFdBQVcvRCxNQUFNLEdBQUc7UUFDdEI7SUFDRjtJQUVBLElBQUkrRCxXQUFXL0QsTUFBTSxFQUNuQjRELFVBQVVHO0lBRVosT0FBT047QUFDVDtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTUyxVQUFVMUQsSUFBSTtJQUNyQixNQUFNSyxTQUFTTixTQUFTQztJQUN4QixNQUFNMkQsU0FBU1gsU0FBUzNDLFFBQVFpRCxJQUFJLENBQUM7SUFDckMsT0FBT0s7QUFDVDtBQUVBLFlBQVk7QUFDWixNQUFNQyxZQUFZLGtCQUFrQixHQUFHO0lBQ3JDQyxZQUFZdEc7QUFDZDtBQU1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N1Z2FyLWhpZ2gvbGliL2luZGV4LmpzP2Y2MWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQHRzLWNoZWNrXG5cbmNvbnN0IGpzeEJyYWNrZXRzID0gbmV3IFNldChbJzwnLCAnPicsICd7JywgJ30nLCAnWycsICddJ10pXG5jb25zdCBrZXl3b3JkcyA9IG5ldyBTZXQoW1xuICAnZm9yJyxcbiAgJ2RvJyxcbiAgJ3doaWxlJyxcbiAgJ2lmJyxcbiAgJ2Vsc2UnLFxuICAncmV0dXJuJyxcbiAgJ2Z1bmN0aW9uJyxcbiAgJ3ZhcicsXG4gICdsZXQnLFxuICAnY29uc3QnLFxuICAndHJ1ZScsXG4gICdmYWxzZScsXG4gICd1bmRlZmluZWQnLFxuICAndGhpcycsXG4gICduZXcnLFxuICAnZGVsZXRlJyxcbiAgJ3R5cGVvZicsXG4gICdpbicsXG4gICdpbnN0YW5jZW9mJyxcbiAgJ3ZvaWQnLFxuICAnYnJlYWsnLFxuICAnY29udGludWUnLFxuICAnc3dpdGNoJyxcbiAgJ2Nhc2UnLFxuICAnZGVmYXVsdCcsXG4gICd0aHJvdycsXG4gICd0cnknLFxuICAnY2F0Y2gnLFxuICAnZmluYWxseScsXG4gICdkZWJ1Z2dlcicsXG4gICd3aXRoJyxcbiAgJ3lpZWxkJyxcbiAgJ2FzeW5jJyxcbiAgJ2F3YWl0JyxcbiAgJ2NsYXNzJyxcbiAgJ2V4dGVuZHMnLFxuICAnc3VwZXInLFxuICAnaW1wb3J0JyxcbiAgJ2V4cG9ydCcsXG4gICdmcm9tJyxcbiAgJ3N0YXRpYycsXG5dKVxuXG5jb25zdCBzaWducyA9IG5ldyBTZXQoW1xuICAnKycsXG4gICctJyxcbiAgJyonLFxuICAnLycsXG4gICclJyxcbiAgJz0nLFxuICAnIScsXG4gICcmJyxcbiAgJ3wnLFxuICAnXicsXG4gICd+JyxcbiAgJyEnLFxuICAnPycsXG4gICc6JyxcbiAgJy4nLFxuICAnLCcsXG4gICc7JyxcbiAgYCdgLFxuICAnXCInLFxuICAnLicsXG4gICcoJyxcbiAgJyknLFxuICAnWycsXG4gICddJyxcbiAgJyMnLFxuICAnQCcsXG4gICdcXFxcJyxcbiAgLi4uanN4QnJhY2tldHMsXG5dKVxuXG5cbi8qKlxuICpcbiAqIDAgIC0gaWRlbnRpZmllclxuICogMSAgLSBrZXl3b3JkXG4gKiAyICAtIHN0cmluZ1xuICogMyAgLSBDbGFzcywgbnVtYmVyIGFuZCBudWxsXG4gKiA0ICAtIHByb3BlcnR5XG4gKiA1ICAtIGVudGl0eVxuICogNiAgLSBqc3ggbGl0ZXJhbHNcbiAqIDcgIC0gc2lnblxuICogOCAgLSBjb21tZW50XG4gKiA5ICAtIGJyZWFrXG4gKiAxMCAtIHNwYWNlXG4gKlxuICovXG5jb25zdCB0eXBlcyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbXG4gICdpZGVudGlmaWVyJyxcbiAgJ2tleXdvcmQnLFxuICAnc3RyaW5nJyxcbiAgJ2NsYXNzJyxcbiAgJ3Byb3BlcnR5JyxcbiAgJ2VudGl0eScsXG4gICdqc3hsaXRlcmFscycsXG4gICdzaWduJyxcbiAgJ2NvbW1lbnQnLFxuICAnYnJlYWsnLFxuICAnc3BhY2UnLFxuXSlcbmNvbnN0IFtcbiAgVF9JREVOVElGSUVSLFxuICBUX0tFWVdPUkQsXG4gIFRfU1RSSU5HLFxuICBUX0NMU19OVU1CRVIsXG4gIFRfUFJPUEVSVFksXG4gIFRfRU5USVRZLFxuICBUX0pTWF9MSVRFUkFMUyxcbiAgVF9TSUdOLFxuICBUX0NPTU1FTlQsXG4gIFRfQlJFQUssXG4gIFRfU1BBQ0UsXG5dID0gLyoqIEB0eXBlcyB7Y29uc3R9ICovIHR5cGVzLm1hcCgoXywgaSkgPT4gaSlcblxuZnVuY3Rpb24gaXNTcGFjZXMoc3RyKSB7XG4gIHJldHVybiAvXlteXFxTXFxyXFxuXSskL2cudGVzdChzdHIpXG59XG5cbmZ1bmN0aW9uIGlzU2lnbihjaCkge1xuICByZXR1cm4gc2lnbnMuaGFzKGNoKVxufVxuXG5mdW5jdGlvbiBlbmNvZGUoc3RyKSB7XG4gIHJldHVybiBzdHJcbiAgICAucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgIC5yZXBsYWNlKC8nL2csICcmIzAzOTsnKVxufVxuXG5mdW5jdGlvbiBpc1dvcmQoY2hyKSB7XG4gIHJldHVybiAvXltcXHdfXSskLy50ZXN0KGNocikgfHwgaGFzVW5pY29kZShjaHIpXG59XG5cbmZ1bmN0aW9uIGlzQ2xzKHN0cikge1xuICBjb25zdCBjaHIwID0gc3RyWzBdXG4gIHJldHVybiBpc1dvcmQoY2hyMCkgJiZcbiAgICBjaHIwID09PSBjaHIwLnRvVXBwZXJDYXNlKCkgfHxcbiAgICBzdHIgPT09ICdudWxsJ1xufVxuXG5mdW5jdGlvbiBoYXNVbmljb2RlKHMpIHtcbiAgcmV0dXJuIC9bXlxcdTAwMDAtXFx1MDA3Zl0vLnRlc3Qocyk7XG59XG5cbmZ1bmN0aW9uIGlzQWxwaGEoY2hyKSB7XG4gIHJldHVybiAvXlthLXpBLVpdJC8udGVzdChjaHIpXG59XG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllckNoYXIoY2hyKSB7XG4gIHJldHVybiBpc0FscGhhKGNocikgfHwgaGFzVW5pY29kZShjaHIpXG59XG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllcihzdHIpIHtcbiAgcmV0dXJuIGlzSWRlbnRpZmllckNoYXIoc3RyWzBdKSAmJiAoc3RyLmxlbmd0aCA9PT0gMSB8fCBpc1dvcmQoc3RyLnNsaWNlKDEpKSlcbn1cblxuZnVuY3Rpb24gaXNTdHJUZW1wbGF0ZUNocihjaHIpIHtcbiAgcmV0dXJuIGNociA9PT0gJ2AnXG59XG5cbmZ1bmN0aW9uIGlzU2luZ2xlUXVvdGVzKGNocikge1xuICByZXR1cm4gY2hyID09PSAnXCInIHx8IGNociA9PT0gXCInXCJcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdRdW90YXRpb24oY2hyKSB7XG4gIHJldHVybiBpc1NpbmdsZVF1b3RlcyhjaHIpIHx8IGlzU3RyVGVtcGxhdGVDaHIoY2hyKVxufVxuXG5mdW5jdGlvbiBpc0NvbW1lbnRTdGFydChzdHIpIHtcbiAgc3RyID0gc3RyLnNsaWNlKDAsIDIpXG4gIHJldHVybiBzdHIgPT09ICcvLycgfHwgc3RyID09PSAnLyonXG59XG5cbmZ1bmN0aW9uIGlzUmVnZXhTdGFydChzdHIpIHtcbiAgcmV0dXJuIHN0clswXSA9PT0gJy8nICYmICFpc0NvbW1lbnRTdGFydChzdHJbMF0gKyBzdHJbMV0pXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiAqIEByZXR1cm4ge0FycmF5PFtudW1iZXIsIHN0cmluZ10+fVxuICovXG5mdW5jdGlvbiB0b2tlbml6ZShjb2RlKSB7XG4gIGxldCBjdXJyZW50ID0gJydcbiAgbGV0IHR5cGUgPSAtMVxuICAvKiogQHR5cGUge1tudW1iZXIsIHN0cmluZ119ICovXG4gIGxldCBsYXN0ID0gWy0xLCAnJ11cbiAgLyoqIEB0eXBlIHtbbnVtYmVyLCBzdHJpbmddfSAqL1xuICBsZXQgYmVmb3JlTGFzdCA9IFstMiwgJyddXG4gIC8qKiBAdHlwZSB7QXJyYXk8W251bWJlciwgc3RyaW5nXT59ICovXG4gIGNvbnN0IHRva2VucyA9IFtdXG5cbiAgLyoqIEB0eXBlIGJvb2xlYW4gaWYgZW50ZXJlZCBqc3ggdGFnLCBpbnNpZGUgPG9wZW4gdGFnPiBvciA8L2Nsb3NlIHRhZz4gKi9cbiAgbGV0IF9fanN4RW50ZXIgPSBmYWxzZVxuICAvKipcbiAgICogQHR5cGUgezAgfCAxIHwgMn1cbiAgICogQGV4YW1wbGVcbiAgICogMCBmb3Igbm90IGluIGpzeDtcbiAgICogMSBmb3Igb3BlbiBqc3ggdGFnO1xuICAgKiAyIGZvciBjbG9zaW5nIGpzeCB0YWc7XG4gICAqKi9cbiAgbGV0IF9fanN4VGFnID0gMFxuICBsZXQgX19qc3hFeHByID0gZmFsc2VcblxuICAvLyBvbmx5IG1hdGNoIHBhaXJlZCAob3BlbiArIGNsb3NlKSB0YWdzLCBub3Qgc2VsZi1jbG9zaW5nIHRhZ3NcbiAgbGV0IF9fanN4U3RhY2sgPSAwXG4gIGNvbnN0IF9fanN4Q2hpbGQgPSAoKSA9PiBfX2pzeEVudGVyICYmICFfX2pzeEV4cHIgJiYgIV9fanN4VGFnXG4gIC8vIDwgX19jb250ZW50X18gPlxuICBjb25zdCBpbkpzeFRhZyA9ICgpID0+IF9fanN4VGFnICYmICFfX2pzeENoaWxkKClcbiAgLy8geydfX2NvbnRlbnRfXyd9XG4gIGNvbnN0IGluSnN4TGl0ZXJhbHMgPSAoKSA9PiAhX19qc3hUYWcgJiYgX19qc3hDaGlsZCgpICYmICFfX2pzeEV4cHIgJiYgX19qc3hTdGFjayA+IDBcblxuICAvKiogQHR5cGUge3N0cmluZyB8IG51bGx9ICovXG4gIGxldCBfX3N0clF1b3RlID0gbnVsbFxuICBsZXQgX19zdHJUZW1wbGF0ZUV4cHJTdGFjayA9IDBcbiAgbGV0IF9fc3RyVGVtcGxhdGVRdW90ZVN0YWNrID0gMFxuICBjb25zdCBpblN0cmluZ1F1b3RlcyA9ICgpID0+IF9fc3RyUXVvdGUgIT09IG51bGxcbiAgY29uc3QgaW5TdHJUZW1wbGF0ZUxpdGVyYWxzID0gKCkgPT4gKF9fc3RyVGVtcGxhdGVRdW90ZVN0YWNrID4gX19zdHJUZW1wbGF0ZUV4cHJTdGFjaylcbiAgY29uc3QgaW5TdHJUZW1wbGF0ZUV4cHIgPSAoKSA9PiBfX3N0clRlbXBsYXRlUXVvdGVTdGFjayA+IDAgJiYgKF9fc3RyVGVtcGxhdGVRdW90ZVN0YWNrID09PSBfX3N0clRlbXBsYXRlRXhwclN0YWNrKVxuICBjb25zdCBpblN0cmluZ0NvbnRlbnQgPSAoKSA9PiBpblN0cmluZ1F1b3RlcygpIHx8IGluU3RyVGVtcGxhdGVMaXRlcmFscygpXG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlblxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gY2xhc3NpZnkodG9rZW4pIHtcbiAgICBjb25zdCBpc0xpbmVCcmVhayA9IHRva2VuID09PSAnXFxuJ1xuICAgIC8vIEZpcnN0IGNoZWNraW5nIGlmIHRoZXkncmUgYXR0cmlidXRlcyB2YWx1ZXNcbiAgICBpZiAoaW5Kc3hUYWcoKSkge1xuICAgICAgaWYgKGluU3RyaW5nUXVvdGVzKCkpIHtcbiAgICAgICAgcmV0dXJuIFRfU1RSSU5HXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IFssIGxhc3RUb2tlbl0gPSBsYXN0XG4gICAgICBpZiAoaXNJZGVudGlmaWVyKHRva2VuKSkge1xuICAgICAgICAvLyBjbGFzc2lmeSBqc3ggb3BlbiB0YWdcbiAgICAgICAgaWYgKChsYXN0VG9rZW4gPT09ICc8JyB8fCBsYXN0VG9rZW4gPT09ICc8LycpKSBcbiAgICAgICAgICByZXR1cm4gVF9FTlRJVFlcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhlbiBkZXRlcm1pbmUgaWYgdGhleSdyZSBqc3ggbGl0ZXJhbHNcbiAgICBjb25zdCBpc0pzeExpdGVyYWxzID0gaW5Kc3hMaXRlcmFscygpXG4gICAgaWYgKGlzSnN4TGl0ZXJhbHMpIHJldHVybiBUX0pTWF9MSVRFUkFMU1xuXG4gICAgLy8gRGV0ZXJtaW5lIHN0cmluZ3MgZmlyc3QgYmVmb3JlIG90aGVyIHR5cGVzXG4gICAgaWYgKGluU3RyaW5nUXVvdGVzKCkpIHtcbiAgICAgIHJldHVybiBUX1NUUklOR1xuICAgIH0gZWxzZSBpZiAoa2V5d29yZHMuaGFzKHRva2VuKSkge1xuICAgICAgcmV0dXJuIGxhc3RbMV0gPT09ICcuJyA/IFRfSURFTlRJRklFUiA6IFRfS0VZV09SRFxuICAgIH0gZWxzZSBpZiAoaXNMaW5lQnJlYWspIHtcbiAgICAgIHJldHVybiBUX0JSRUFLXG4gICAgfSBlbHNlIGlmIChpc1NwYWNlcyh0b2tlbikpIHtcbiAgICAgIHJldHVybiBUX1NQQUNFXG4gICAgfSBlbHNlIGlmICh0b2tlbi5zcGxpdCgnJykuZXZlcnkoaXNTaWduKSkge1xuICAgICAgcmV0dXJuIFRfU0lHTlxuICAgIH0gZWxzZSBpZiAoaXNDbHModG9rZW4pKSB7XG4gICAgICByZXR1cm4gaW5Kc3hUYWcoKSA/IFRfSURFTlRJRklFUiA6IFRfQ0xTX05VTUJFUlxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNJZGVudGlmaWVyKHRva2VuKSkge1xuICAgICAgICBjb25zdCBpc0xhc3RQcm9wRG90ID0gbGFzdFsxXSA9PT0gJy4nICYmIGlzSWRlbnRpZmllcihiZWZvcmVMYXN0WzFdKVxuXG4gICAgICAgIGlmICghaW5TdHJpbmdDb250ZW50KCkgJiYgIWlzTGFzdFByb3BEb3QpIHJldHVybiBUX0lERU5USUZJRVJcbiAgICAgICAgaWYgKGlzTGFzdFByb3BEb3QpIHJldHVybiBUX1BST1BFUlRZXG4gICAgICB9XG4gICAgICByZXR1cm4gVF9TVFJJTkdcbiAgICB9XG4gIH1cblxuICBjb25zdCBhcHBlbmQgPSAoX3R5cGUsIF90b2tlbikgPT4ge1xuICAgIGlmIChfdG9rZW4pIHtcbiAgICAgIGN1cnJlbnQgPSBfdG9rZW5cbiAgICB9XG4gICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgIHR5cGUgPSBfdHlwZSB8fCBjbGFzc2lmeShjdXJyZW50KVxuICAgICAgLyoqIEB0eXBlIFtudW1iZXIsIHN0cmluZ10gICovXG4gICAgICBjb25zdCBwYWlyID0gW3R5cGUsIGN1cnJlbnRdXG4gICAgICBpZiAodHlwZSAhPT0gVF9TUEFDRSAmJiB0eXBlICE9PSBUX0JSRUFLKSB7XG4gICAgICAgIGJlZm9yZUxhc3QgPSBsYXN0XG4gICAgICAgIGxhc3QgPSBwYWlyXG4gICAgICB9XG4gICAgICB0b2tlbnMucHVzaChwYWlyKVxuICAgIH1cbiAgICBjdXJyZW50ID0gJydcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjdXJyID0gY29kZVtpXVxuICAgIGNvbnN0IHByZXYgPSBjb2RlW2kgLSAxXVxuICAgIGNvbnN0IG5leHQgPSBjb2RlW2kgKyAxXVxuICAgIGNvbnN0IHBfYyA9IHByZXYgKyBjdXJyIC8vIHByZXZpb3VzIGFuZCBjdXJyZW50XG4gICAgY29uc3QgY19uID0gY3VyciArIG5leHQgLy8gY3VycmVudCBhbmQgbmV4dFxuXG4gICAgLy8gRGV0ZXJtaW5lIHN0cmluZyBxdW90YXRpb24gb3V0c2lkZSBvZiBqc3ggbGl0ZXJhbHMuXG4gICAgLy8gSW5zaWRlIGpzeCBsaXRlcmFscywgc3RyaW5nIHF1b3RhdGlvbiBpcyBzdGlsbCBwYXJ0IG9mIGl0LlxuICAgIGlmIChpc1NpbmdsZVF1b3RlcyhjdXJyKSAmJiAhaW5Kc3hMaXRlcmFscygpKSB7XG4gICAgICBhcHBlbmQoKVxuICAgICAgaWYgKHByZXYgIT09IGBcXFxcYCkge1xuICAgICAgICBpZiAoX19zdHJRdW90ZSAmJiBjdXJyID09PSBfX3N0clF1b3RlKSB7XG4gICAgICAgICAgX19zdHJRdW90ZSA9IG51bGxcbiAgICAgICAgfSBlbHNlIGlmICghX19zdHJRdW90ZSkge1xuICAgICAgICAgIF9fc3RyUXVvdGUgPSBjdXJyXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYXBwZW5kKFRfU1RSSU5HLCBjdXJyKVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoIWluU3RyVGVtcGxhdGVMaXRlcmFscygpKSB7XG4gICAgICBpZiAocHJldiAhPT0gJ1xcXFxuJyAmJiBpc1N0clRlbXBsYXRlQ2hyKGN1cnIpKSB7XG4gICAgICAgIGFwcGVuZCgpXG4gICAgICAgIGFwcGVuZChUX1NUUklORywgY3VycilcbiAgICAgICAgX19zdHJUZW1wbGF0ZVF1b3RlU3RhY2srK1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpblN0clRlbXBsYXRlTGl0ZXJhbHMoKSkge1xuICAgICAgaWYgKHByZXYgIT09ICdcXFxcbicgJiYgaXNTdHJUZW1wbGF0ZUNocihjdXJyKSkge1xuICAgICAgICBpZiAoX19zdHJUZW1wbGF0ZVF1b3RlU3RhY2sgPiAwKSB7XG4gICAgICAgICAgYXBwZW5kKClcbiAgICAgICAgICBfX3N0clRlbXBsYXRlUXVvdGVTdGFjay0tXG4gICAgICAgICAgYXBwZW5kKFRfU1RSSU5HLCBjdXJyKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNfbiA9PT0gJyR7Jykge1xuICAgICAgICBfX3N0clRlbXBsYXRlRXhwclN0YWNrKytcbiAgICAgICAgYXBwZW5kKFRfU1RSSU5HKVxuICAgICAgICBhcHBlbmQoVF9TSUdOLCBjX24pXG4gICAgICAgIGkrK1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpblN0clRlbXBsYXRlRXhwcigpICYmIGN1cnIgPT09ICd9Jykge1xuICAgICAgYXBwZW5kKClcbiAgICAgIF9fc3RyVGVtcGxhdGVFeHByU3RhY2stLVxuICAgICAgYXBwZW5kKFRfU0lHTiwgY3VycilcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKF9fanN4Q2hpbGQoKSkge1xuICAgICAgaWYgKGN1cnIgPT09ICd7Jykge1xuICAgICAgICBhcHBlbmQoKVxuICAgICAgICBhcHBlbmQoVF9TSUdOLCBjdXJyKVxuICAgICAgICBfX2pzeEV4cHIgPSB0cnVlXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKF9fanN4RW50ZXIpIHtcbiAgICAgIC8vIDw6IG9wZW4gdGFnIHNpZ25cbiAgICAgIC8vIG5ldyAnPCcgbm90IGluc2lkZSBqc3hcbiAgICAgIGlmICghX19qc3hUYWcgJiYgY3VyciA9PT0gJzwnKSB7XG4gICAgICAgIGFwcGVuZCgpXG4gICAgICAgIGlmIChuZXh0ID09PSAnLycpIHtcbiAgICAgICAgICAvLyBjbG9zZSB0YWdcbiAgICAgICAgICBfX2pzeFRhZyA9IDJcbiAgICAgICAgICBjdXJyZW50ID0gY19uXG4gICAgICAgICAgaSsrXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb3BlbiB0YWdcbiAgICAgICAgICBfX2pzeFRhZyA9IDFcbiAgICAgICAgICBjdXJyZW50ID0gY3VyclxuICAgICAgICB9XG4gICAgICAgIGFwcGVuZChUX1NJR04pXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBpZiAoX19qc3hUYWcpIHtcbiAgICAgICAgLy8gPjogb3BlbiB0YWcgY2xvc2Ugc2lnbiBvciBjbG9zaW5nIHRhZyBjbG9zaW5nIHNpZ25cbiAgICAgICAgLy8gYW5kIGl0J3Mgbm90IGA9PmAgb3IgYC8+YFxuICAgICAgICAvLyBgY3VycmAgY291bGQgYmUgYD5gIG9yIGAvYFxuICAgICAgICBpZiAoKGN1cnIgPT09ICc+JyAmJiAhJy89Jy5pbmNsdWRlcyhwcmV2KSkpIHtcbiAgICAgICAgICBhcHBlbmQoKVxuICAgICAgICAgIGlmIChfX2pzeFRhZyA9PT0gMSkge1xuICAgICAgICAgICAgX19qc3hUYWcgPSAwXG4gICAgICAgICAgICBfX2pzeFN0YWNrKytcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX19qc3hUYWcgPSAwXG4gICAgICAgICAgICBfX2pzeEVudGVyID0gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgICAgYXBwZW5kKFRfU0lHTiwgY3VycilcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gPjogdGFnIHNlbGYgY2xvc2Ugc2lnbiBvciBjbG9zZSB0YWcgc2lnblxuICAgICAgICBpZiAoY19uID09PSAnLz4nIHx8IGNfbiA9PT0gJzwvJykge1xuICAgICAgICAgIC8vIGlmIGN1cnJlbnQgdG9rZW4gaXMgbm90IHBhcnQgb2YgY2xvc2UgdGFnIHNpZ24sIHB1c2ggaXQgZmlyc3RcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gJzwnICYmIGN1cnJlbnQgIT09ICcvJykge1xuICAgICAgICAgICAgYXBwZW5kKClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY19uID09PSAnLz4nKSB7XG4gICAgICAgICAgICBfX2pzeFRhZyA9IDBcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXMgJzwvJ1xuICAgICAgICAgICAgX19qc3hTdGFjay0tXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFfX2pzeFN0YWNrKVxuICAgICAgICAgICAgX19qc3hFbnRlciA9IGZhbHNlXG5cbiAgICAgICAgICBjdXJyZW50ID0gY19uXG4gICAgICAgICAgaSsrXG4gICAgICAgICAgYXBwZW5kKFRfU0lHTilcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gPDogb3BlbiB0YWcgc2lnblxuICAgICAgICBpZiAoY3VyciA9PT0gJzwnKSB7XG4gICAgICAgICAgYXBwZW5kKClcbiAgICAgICAgICBjdXJyZW50ID0gY3VyclxuICAgICAgICAgIGFwcGVuZChUX1NJR04pXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGpzeCBwcm9wZXJ0eVxuICAgICAgICAvLyBgLWAgaW4gZGF0YS1wcm9wXG4gICAgICAgIGlmIChuZXh0ID09PSAnLScgICYmICFpblN0cmluZ0NvbnRlbnQoKSAmJiAhaW5Kc3hMaXRlcmFscygpKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGFwcGVuZChUX1BST1BFUlRZLCBjdXJyZW50ICsgY3VyciArIG5leHQpXG4gICAgICAgICAgICBpICs9IDFcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGA9YCBpbiBwcm9wZXJ0eT08dmFsdWU+XG4gICAgICAgIGlmIChuZXh0ID09PSAnPScgJiYgIWluU3RyaW5nQ29udGVudCgpKSB7XG4gICAgICAgICAgY29uc3QgcHJvcCA9IGN1cnJlbnQgPyAoY3VycmVudCArIGN1cnIpIDogY3VyclxuICAgICAgICAgIGlmIChpc0lkZW50aWZpZXIocHJvcCkpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBwcm9wXG4gICAgICAgICAgICBhcHBlbmQoVF9QUk9QRVJUWSlcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIGl0J3Mgbm90IGluIGEganN4IHRhZyBkZWNsYXJhdGlvbiBvciBhIHN0cmluZywgY2xvc2UgY2hpbGQgaWYgbmV4dCBpcyBqc3ggY2xvc2UgdGFnXG4gICAgaWYgKCFfX2pzeFRhZyAmJiAoY3VyciA9PT0gJzwnICYmIGlzSWRlbnRpZmllckNoYXIobmV4dCkgfHwgY19uID09PSAnPC8nKSkge1xuICAgICAgX19qc3hUYWcgPSBuZXh0ID09PSAnLycgPyAyIDogMVxuXG4gICAgICAvLyBjdXJyZW50IGFuZCBuZXh0IGNoYXIgY2FuIGZvcm0gYSBqc3ggb3BlbiBvciBjbG9zZSB0YWdcbiAgICAgIGlmIChjdXJyID09PSAnPCcgJiYgKG5leHQgPT09ICcvJyB8fCBpc0FscGhhKG5leHQpKSkge1xuICAgICAgICBfX2pzeEVudGVyID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGlzUXVvdGF0aW9uQ2hhciA9IGlzU3RyaW5nUXVvdGF0aW9uKGN1cnIpXG4gICAgY29uc3QgaXNTdHJpbmdUZW1wbGF0ZUxpdGVyYWxzID0gaW5TdHJUZW1wbGF0ZUxpdGVyYWxzKClcbiAgICBjb25zdCBpc1JlZ2V4Q2hhciA9ICFfX2pzeEVudGVyICYmIGlzUmVnZXhTdGFydChjX24pXG4gICAgY29uc3QgaXNKc3hMaXRlcmFscyA9IGluSnN4TGl0ZXJhbHMoKVxuXG4gICAgLy8gc3RyaW5nIHF1b3RhdGlvblxuICAgIGlmIChpc1F1b3RhdGlvbkNoYXIgfHwgaXNTdHJpbmdUZW1wbGF0ZUxpdGVyYWxzIHx8IGlzU2luZ2xlUXVvdGVzKF9fc3RyUXVvdGUpKSB7XG4gICAgICBjdXJyZW50ICs9IGN1cnJcbiAgICB9IGVsc2UgaWYgKGlzUmVnZXhDaGFyKSB7XG4gICAgICBhcHBlbmQoKVxuICAgICAgY29uc3QgW2xhc3RUeXBlLCBsYXN0VG9rZW5dID0gbGFzdFxuICAgICAgLy8gU3BlY2lhbCBjYXNlcyB0aGF0IGFyZSBub3QgY29uc2lkZXJlZCBhcyByZWdleDpcbiAgICAgIC8vICogKGV4cHIxKSAvIGV4cHIyOiBgKWAgYmVmb3JlIGAvYCBvcGVyYXRvciBpcyBzdGlsbCBpbiBleHByZXNzaW9uXG4gICAgICAvLyAqIDxub24gY29tbWVudCBzdGFydD4vIGV4cHI6IG5vbiBjb21tZW50IHN0YXJ0IGJlZm9yZSBgL2AgaXMgbm90IHJlZ2V4XG4gICAgICBpZiAoXG4gICAgICAgIGlzUmVnZXhDaGFyICYmXG4gICAgICAgIGxhc3RUeXBlICE9PSAtMSAmJlxuICAgICAgICAhKFxuICAgICAgICAgIChsYXN0VHlwZSA9PT0gVF9TSUdOICYmICcpJyAhPT0gbGFzdFRva2VuKSB8fFxuICAgICAgICAgIGxhc3RUeXBlID09PSBUX0NPTU1FTlRcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyXG4gICAgICAgIGFwcGVuZCgpXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0YXJ0ID0gaSsrXG5cbiAgICAgIC8vIGVuZCBvZiBsaW5lIG9mIGVuZCBvZiBmaWxlXG4gICAgICBjb25zdCBpc0VvZiA9ICgpID0+IGkgPj0gY29kZS5sZW5ndGhcbiAgICAgIGNvbnN0IGlzRW9sID0gKCkgPT4gaXNFb2YoKSB8fCBjb2RlW2ldID09PSAnXFxuJ1xuXG4gICAgICBsZXQgZm91bmRDbG9zZSA9IGZhbHNlXG4gICAgICAvLyByZWdleFxuICAgICAgZm9yICg7ICFpc0VvbCgpOyBpKyspIHtcbiAgICAgICAgaWYgKGNvZGVbaV0gPT09ICcvJyAmJiBjb2RlW2kgLSAxXSAhPT0gJ1xcXFwnKSB7XG4gICAgICAgICAgZm91bmRDbG9zZSA9IHRydWVcbiAgICAgICAgICAvLyBhcHBlbmQgcmVnZXggZmxhZ3NcbiAgICAgICAgICB3aGlsZSAoc3RhcnQgIT09IGkgJiYgL15bYS16XSQvLnRlc3QoY29kZVtpICsgMV0pICYmICFpc0VvbCgpKSB7XG4gICAgICAgICAgICBpKytcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ICE9PSBpICYmIGZvdW5kQ2xvc2UpIHtcbiAgICAgICAgLy8gSWYgY3VycmVudCBsaW5lIGlzIGZ1bGx5IGNsb3NlZCB3aXRoIHN0cmluZyBxdW90ZXMgb3IgcmVnZXggc2xhc2hlcyxcbiAgICAgICAgLy8gYWRkIHRoZW0gdG8gdG9rZW5zXG4gICAgICAgIGN1cnJlbnQgPSBjb2RlLnNsaWNlKHN0YXJ0LCBpICsgMSlcbiAgICAgICAgYXBwZW5kKFRfU1RSSU5HKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgaXQgZG9lc24ndCBtYXRjaCBhbnkgb2YgdGhlIGFib3ZlLCBqdXN0IGxlYXZlIGl0IGFzIG9wZXJhdG9yIGFuZCBtb3ZlIG9uXG4gICAgICAgIGN1cnJlbnQgPSBjdXJyXG4gICAgICAgIGFwcGVuZCgpXG4gICAgICAgIGkgPSBzdGFydFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNDb21tZW50U3RhcnQoY19uKSkge1xuICAgICAgYXBwZW5kKClcbiAgICAgIGNvbnN0IHN0YXJ0ID0gaVxuICAgICAgaWYgKG5leHQgPT09ICcvJykge1xuICAgICAgICBmb3IgKDsgaSA8IGNvZGUubGVuZ3RoICYmIGNvZGVbaV0gIT09ICdcXG4nOyBpKyspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICg7IGkgPCBjb2RlLmxlbmd0aCAmJiBjb2RlW2kgLSAxXSArIGNvZGVbaV0gIT09ICcqLyc7IGkrKyk7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY29kZS5zbGljZShzdGFydCwgaSArIDEpXG4gICAgICBhcHBlbmQoVF9DT01NRU5UKVxuICAgIH0gZWxzZSBpZiAoY3VyciA9PT0gJyAnIHx8IGN1cnIgPT09ICdcXG4nKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGN1cnIgPT09ICcgJyAmJlxuICAgICAgICAoXG4gICAgICAgICAgKGlzU3BhY2VzKGN1cnJlbnQpIHx8ICFjdXJyZW50KSB8fFxuICAgICAgICAgIGlzSnN4TGl0ZXJhbHNcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnQgKz0gY3VyclxuICAgICAgICBpZiAobmV4dCA9PT0gJzwnKSB7XG4gICAgICAgICAgYXBwZW5kKClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBwZW5kKClcbiAgICAgICAgY3VycmVudCA9IGN1cnJcbiAgICAgICAgYXBwZW5kKClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKF9fanN4RXhwciAmJiBjdXJyID09PSAnfScpIHtcbiAgICAgICAgYXBwZW5kKClcbiAgICAgICAgY3VycmVudCA9IGN1cnJcbiAgICAgICAgYXBwZW5kKClcbiAgICAgICAgX19qc3hFeHByID0gZmFsc2VcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIC8vIGl0J3MganN4IGxpdGVyYWxzIGFuZCBpcyBub3QgYSBqc3ggYnJhY2tldFxuICAgICAgICAoaXNKc3hMaXRlcmFscyAmJiAhanN4QnJhY2tldHMuaGFzKGN1cnIpKSB8fFxuICAgICAgICAvLyBzYW1lIHR5cGUgY2hhciBhcyBwcmV2aW91cyBvbmUgaW4gY3VycmVudCB0b2tlblxuICAgICAgICAoKGlzV29yZChjdXJyKSA9PT0gaXNXb3JkKGN1cnJlbnRbY3VycmVudC5sZW5ndGggLSAxXSkgfHwgX19qc3hDaGlsZCgpKSAmJiAhc2lnbnMuaGFzKGN1cnIpKVxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnQgKz0gY3VyclxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBfYyA9PT0gJzwvJykge1xuICAgICAgICAgIGN1cnJlbnQgPSBwX2NcbiAgICAgICAgfVxuICAgICAgICBhcHBlbmQoKVxuXG4gICAgICAgIGlmIChwX2MgIT09ICc8LycpIHtcbiAgICAgICAgICBjdXJyZW50ID0gY3VyclxuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKChjX24gPT09ICc8LycgfHwgY19uID09PSAnLz4nKSkge1xuICAgICAgICAgIGN1cnJlbnQgPSBjX25cbiAgICAgICAgICBhcHBlbmQoKVxuICAgICAgICAgIGkrK1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGpzeEJyYWNrZXRzLmhhcyhjdXJyKSkgYXBwZW5kKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhcHBlbmQoKVxuXG4gIHJldHVybiB0b2tlbnNcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFtudW1iZXIsIHN0cmluZ10+fSB0b2tlbnNcbiAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59XG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlKHRva2Vucykge1xuICBjb25zdCBsaW5lc0h0bWwgPSBbXVxuICBjb25zdCBjcmVhdGVMaW5lID0gKGNvbnRlbnQpID0+IGA8c3BhbiBjbGFzcz1cInNoX19saW5lXCI+JHtjb250ZW50fTwvc3Bhbj5gXG5cbiAgZnVuY3Rpb24gZmx1c2hMaW5lKHRva2Vucykge1xuICAgIGxpbmVzSHRtbC5wdXNoKGNyZWF0ZUxpbmUoXG4gICAgICB0b2tlbnMubWFwKChbdHlwZSwgdmFsdWVdKSA9PiAoXG4gICAgICAgIGA8c3BhbiBjbGFzcz1cInNoX190b2tlbi0tJHt0eXBlc1t0eXBlXX1cIiBzdHlsZT1cImNvbG9yOiB2YXIoLS1zaC0ke3R5cGVzW3R5cGVdfSlcIj4ke2VuY29kZSh2YWx1ZSl9PC9zcGFuPmBcbiAgICAgICkpXG4gICAgICAuam9pbignJylcbiAgICApKVxuICB9XG4gIGNvbnN0IGxpbmVUb2tlbnMgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRva2VuID0gdG9rZW5zW2ldXG4gICAgY29uc3QgW3R5cGUsIHZhbHVlXSA9IHRva2VuXG4gICAgaWYgKHR5cGUgIT09IFRfQlJFQUspIHtcbiAgICAgIC8vIERpdmlkZSBtdWx0aS1saW5lIHRva2VuIGludG8gbXVsdGktbGluZSBjb2RlXG4gICAgICBpZiAodmFsdWUuaW5jbHVkZXMoJ1xcbicpKSB7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gdmFsdWUuc3BsaXQoJ1xcbicpXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGluZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBsaW5lVG9rZW5zLnB1c2goW3R5cGUsIGxpbmVzW2pdXSlcbiAgICAgICAgICBpZiAoaiA8IGxpbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGZsdXNoTGluZShsaW5lVG9rZW5zKVxuICAgICAgICAgICAgbGluZVRva2Vucy5sZW5ndGggPSAwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lVG9rZW5zLnB1c2godG9rZW4pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVUb2tlbnMucHVzaChbdHlwZSwgJyddKVxuICAgICAgZmx1c2hMaW5lKGxpbmVUb2tlbnMpXG4gICAgICBsaW5lVG9rZW5zLmxlbmd0aCA9IDBcbiAgICB9XG4gIH1cblxuICBpZiAobGluZVRva2Vucy5sZW5ndGgpXG4gICAgZmx1c2hMaW5lKGxpbmVUb2tlbnMpXG5cbiAgcmV0dXJuIGxpbmVzSHRtbFxufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaGlnaGxpZ2h0KGNvZGUpIHtcbiAgY29uc3QgdG9rZW5zID0gdG9rZW5pemUoY29kZSlcbiAgY29uc3Qgb3V0cHV0ID0gZ2VuZXJhdGUodG9rZW5zKS5qb2luKCdcXG4nKVxuICByZXR1cm4gb3V0cHV0XG59XG5cbi8vIG5hbWVzcGFjZVxuY29uc3QgU3VnYXJIaWdoID0gLyoqIEB0eXBlIHtjb25zdH0gKi8ge1xuICBUb2tlblR5cGVzOiB0eXBlcyxcbn1cblxuZXhwb3J0IHtcbiAgaGlnaGxpZ2h0LFxuICB0b2tlbml6ZSxcbiAgU3VnYXJIaWdoLFxufSJdLCJuYW1lcyI6WyJqc3hCcmFja2V0cyIsIlNldCIsImtleXdvcmRzIiwic2lnbnMiLCJ0eXBlcyIsIlRfSURFTlRJRklFUiIsIlRfS0VZV09SRCIsIlRfU1RSSU5HIiwiVF9DTFNfTlVNQkVSIiwiVF9QUk9QRVJUWSIsIlRfRU5USVRZIiwiVF9KU1hfTElURVJBTFMiLCJUX1NJR04iLCJUX0NPTU1FTlQiLCJUX0JSRUFLIiwiVF9TUEFDRSIsIm1hcCIsIl8iLCJpIiwiaXNTcGFjZXMiLCJzdHIiLCJ0ZXN0IiwiaXNTaWduIiwiY2giLCJoYXMiLCJlbmNvZGUiLCJyZXBsYWNlIiwiaXNXb3JkIiwiY2hyIiwiaGFzVW5pY29kZSIsImlzQ2xzIiwiY2hyMCIsInRvVXBwZXJDYXNlIiwicyIsImlzQWxwaGEiLCJpc0lkZW50aWZpZXJDaGFyIiwiaXNJZGVudGlmaWVyIiwibGVuZ3RoIiwic2xpY2UiLCJpc1N0clRlbXBsYXRlQ2hyIiwiaXNTaW5nbGVRdW90ZXMiLCJpc1N0cmluZ1F1b3RhdGlvbiIsImlzQ29tbWVudFN0YXJ0IiwiaXNSZWdleFN0YXJ0IiwidG9rZW5pemUiLCJjb2RlIiwiY3VycmVudCIsInR5cGUiLCJsYXN0IiwiYmVmb3JlTGFzdCIsInRva2VucyIsIl9fanN4RW50ZXIiLCJfX2pzeFRhZyIsIl9fanN4RXhwciIsIl9fanN4U3RhY2siLCJfX2pzeENoaWxkIiwiaW5Kc3hUYWciLCJpbkpzeExpdGVyYWxzIiwiX19zdHJRdW90ZSIsIl9fc3RyVGVtcGxhdGVFeHByU3RhY2siLCJfX3N0clRlbXBsYXRlUXVvdGVTdGFjayIsImluU3RyaW5nUXVvdGVzIiwiaW5TdHJUZW1wbGF0ZUxpdGVyYWxzIiwiaW5TdHJUZW1wbGF0ZUV4cHIiLCJpblN0cmluZ0NvbnRlbnQiLCJjbGFzc2lmeSIsInRva2VuIiwiaXNMaW5lQnJlYWsiLCJsYXN0VG9rZW4iLCJpc0pzeExpdGVyYWxzIiwic3BsaXQiLCJldmVyeSIsImlzTGFzdFByb3BEb3QiLCJhcHBlbmQiLCJfdHlwZSIsIl90b2tlbiIsInBhaXIiLCJwdXNoIiwiY3VyciIsInByZXYiLCJuZXh0IiwicF9jIiwiY19uIiwiaW5jbHVkZXMiLCJwcm9wIiwiaXNRdW90YXRpb25DaGFyIiwiaXNTdHJpbmdUZW1wbGF0ZUxpdGVyYWxzIiwiaXNSZWdleENoYXIiLCJsYXN0VHlwZSIsInN0YXJ0IiwiaXNFb2YiLCJpc0VvbCIsImZvdW5kQ2xvc2UiLCJnZW5lcmF0ZSIsImxpbmVzSHRtbCIsImNyZWF0ZUxpbmUiLCJjb250ZW50IiwiZmx1c2hMaW5lIiwidmFsdWUiLCJqb2luIiwibGluZVRva2VucyIsImxpbmVzIiwiaiIsImhpZ2hsaWdodCIsIm91dHB1dCIsIlN1Z2FySGlnaCIsIlRva2VuVHlwZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sugar-high/lib/index.js\n");

/***/ })

};
;